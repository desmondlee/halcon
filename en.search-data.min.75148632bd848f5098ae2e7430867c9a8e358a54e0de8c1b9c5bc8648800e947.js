'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href','section'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/docs/%E5%9F%BA%E7%A1%80%E7%AE%97%E5%AD%90%E6%96%B9%E6%B3%95%E5%87%BD%E6%95%B0/','title':"基础算子(方法函数)",'section':"Docs",'content':"基础算子(方法函数) #  图片 #   read_image write_image dump_window dump_window_image draw_rectangle   draw 和 gen 的区别：\n draw 产生的是点位信息， 是控制类型变量， 方便存储和读写； gen 产生的是图像， 是图像类型变量， 用于显示图形； draw 一般和 gen 联合使用，显示绘制的区域。   数组 #   tuple_concat tuple_find tuple_regexp_select  资源句柄 #   dev_get_window  区域计算 #   union1\u0026amp;union2 difference intersection complement   解释，\n union1\u0026amp;union2，合并区域 difference，第一个区域减去其与第二个区域重合部分 intersection，两个区域的重合部分 complement，区域的补集(区域以外部分)   字体 #   query_font get_font set_font   解释,\n query_font，查询系统中可用字体; get_font，获取当前使用字体   "});index.add({'id':1,'href':'/docs/%E9%87%8D%E8%A6%81%E7%AE%97%E5%AD%90/','title':"重要算子",'section':"Docs",'content':"重要算子 #    get_region_xxx: 获取区域点组；\n  get_contour_xld: 获取xld点组；\n  area_center: 求区域面积\n  intensity:\n  shape_trans: 区域形状变换\n  smallest_xxx: 求区域或xld的最小外接圆\n  dyn_threshold, var_threshold ：使用局部均值和标准差分析分割图像\n dyn_threshold, var_threshold 常用于缺陷检测。\n   "});index.add({'id':2,'href':'/docs/image/operators/read_image/','title':"read_image",'section':"相关算子",'content':"read_image #  加载图像到halcon\n"});index.add({'id':3,'href':'/docs/csharp_combine/halcon%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/','title':"Halcon数据类型",'section':"C#联合编程",'content':"Halcon的数据类型 #  命名规范 #  Halcon导出的图像变量类型是HObject，简称 ho；导出的控制变量类型是HTuple，简称 hv。\n图像类型的使用步骤 #   用GenEmptyObj初始化图像变量，或产生一个非空的图像变量； 在更新图像变量的内容前，用Dispose释放资源； 使用图像变量； 图像变量生命周期结束时，用Dispose释放资源。(C#中有GC垃圾回收机制，不强制Dispose；但C++中最好Dispose)   注：如果不及时用Dispose释放资源，可能会导致内存泄漏。\n C#与Halcon数据间转换 #    tuple变量赋值给C#变量：\ncsharp_int = halcon_int[0].I (英文字母i 的大写，表示int)\rcsharp_real = halcon_real[0].D (英文字母d的大写，表示double)\rcsharp_string = halcon_string[0].S (英文字母s的大写，表示string)\r  C#变量赋值给tuple变量：\nhalcon_int = csharp_int * 2; (隐式转换)\rhalcon_int = (HTuple)(csharp_int * 2) (显示强制转换)\rhalcon_int = new HTuple(csharp_int * 2)\r  "});index.add({'id':4,'href':'/docs/csharp_combine/hsmartwindow/','title':"hSmartWindow使用",'section':"C#联合编程",'content':"hSmartWindow使用 #  提醒 #  若将halcon的dll文件拷贝到项目的bin/debug目录，需要同时拷贝以下三个文件，\nhalcon.dll, hcanvas.dll(在halcon安装目录bin下的x64-win64目录)\nhalcondotnet.dll(在halcon安装目录bin下的dotnet35目录)\n原因 #  C#项目的bin/debug目录下有halcon.dll文件时，其优先级高于halcon在系统中的安装路径下的halcon.dll，\n该halcon.dll会引用同目录的其他dll文件，若缺失，则会报错(提示缺失某dll)。\n排查技巧 #   将halcon安装目录bin/x64-win64下的所有dll文件都拷贝到C#项目的bin/debug目录； 运行c#项目，使其能正常执行； 在c#项目运行状态下，删除C#项目的bin/debug目录下拷贝的所有dll文件，同时忽略无法删除部分； 最终剩下的无法删除的dll文件，即是可能需要的dll文件； 再一个个删除剩下的dll文件，运行目录下的exe文件，若报错，说明刚删除的dll文件是必要文件。  "});index.add({'id':5,'href':'/docs/csharp_combine/visualstudio%E9%85%8D%E7%BD%AE/','title':"使用VisualStudio开发halcon的配置",'section':"C#联合编程",'content':"使用VisualStudio开发halcon的配置 #  步骤 #   在项目属性中，生成代码 选项不勾选[首选32位]；※重要 在Form设计界面，打开工具箱， 右键选择选择项， 点击浏览，勾选halcon安装目录下的bin/dotnet35目录下的halcondotnet.dll文件；（此时可以在工具箱中拖拽使用hWindowControl控件了) 添加项目引用，选择halcondotnet.dll文件；（后缀是xl.dll的文件，用于大分辨率相机，如2000万像素以上） (可选项)，若想不依赖系统中的安装程序halcon，需要将相关dll文件放入c#项目的bin/debug目录下。(exe文件目录) (可选项)，Halcon安装目录下的misc目录中，有VS插件HALCON1911ProgressVariableInspect.vsix，双击安装后可以在VisualStudio中右键Halcon类型变量，添加到插件监控中。  实例 #  项目代码文件下载\n ps, vs版本为2017社区版\n 切换版本 #   更换C#项目资源管理器，引用列表中的halcondotnet引用文件； 在工具箱、项目中，都重新引入最新的halcondotnet.dll动态库文件； 重新拖拽生成hWindowControl窗口控件。  快捷键 #    格式化代码\nctrl+k+f\r  "});index.add({'id':6,'href':'/docs/csharp_combine/functions/','title':"常用设置",'section':"C#联合编程",'content':"常用设置 #   设置内部图像处理buffer的宽度和高度  HoperatorSet.SetSystem(\u0026quot;width\u0026quot;, 512);\rHoperatorSet.SetSystem(\u0026quot;height\u0026quot;, 512);\r"});index.add({'id':7,'href':'/docs/image/procedure/','title':"流程",'section':"图像处理",'content':"流程 #   mermaid.initialize({ \"flowchart\": { \"useMaxWidth\":true }, \"theme\": \"default\" } ) graph TD\rA[采集图像] -- B{有无判定, 如Blob分析,几何定位}\rB -- |有| C[获得位置,角度信息]\rB -- |无| A\rC -- D[仿射变换,如求变换句柄 , ROI变换]\rD -- E[图像预处理]\rE -- F[图像处理]\rF -- G[结果输出]\r"});index.add({'id':8,'href':'/docs/image/%E5%B8%B8%E7%94%A8%E6%A0%87%E5%AE%9A/','title':"常用标定",'section':"图像处理",'content':"常用标定 #   像素变换(原型、矩形、像素单量)； 透视投影及光学畸变校正； 不同坐标系之间的标定(三点确定一个坐标系)，如九点定标(机械手)； 多个相机通过标定统一到同一个坐标系。  "});index.add({'id':9,'href':'/docs/image/operators/%E8%BF%9E%E9%80%9A%E6%80%A7%E6%93%8D%E4%BD%9Cconnection/','title':"连通性操作connection",'section':"相关算子",'content':"连通性操作connection #  作用 #  将整体目标拆分成多个独立目标。\n前提 #  需要通过threshold标注出目标。\n使用方式 #  命令connection (Regions, ConnectedRegions)。\n其中，第一个参数 Regions是通过threshold得到的变量，第二个变量ConnectedRegions是connection算子的输出变量。\n执行该命令后，包含在整张图像中的多个目标就被拆分成多个独立目标。(如果右键单击图像，彩色数量选择12，会发现每个独立的目标都被着上了不同的颜色)\n参考图 #  "});index.add({'id':10,'href':'/docs/image/operators/%E7%89%B9%E5%BE%81%E7%9B%B4%E6%96%B9%E5%9B%BE/','title':"特征直方图",'section':"相关算子",'content':"借助特征直方图创建select_shape代码 #  前提 #  先使用 connection 算子将图像上的一整个特征目标，拆分成多个特征目标。\n使用方式 #   将connection 拆分出来的图像用同一种颜色标注(如用灰色)； 打开特征直方图，勾选area选项； 通过拖拽特征直方图上的绿线和红线，使只关注的目标被标注(着色)； 点击插入代码，即可在代码窗口得到对应的代码。如select_shape (ConnectedRegions, SelectedRegions1, 'area', 'and', 28077.7, 50000)  参考图 #  "});index.add({'id':11,'href':'/docs/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/','title':"图像分割",'section':"Docs",'content':"图像分割 #  threshold #  直接阈值分割。适用于环境稳定，目标和背景存在明显的灰度差的场合。阈值一般可以通过灰度直方图来确定。\nbinary_threshold #  自动全局阈值分割。适用于目标物体和背景之间存在明显的灰度差的场合。\n在直方图中会有明显的两个波峰：一个是目标物体，另一个是背景。如果有多个波峰，算子通过平滑灰度直方图，自动找到两个波峰之间的最小值，输出灰度值在0到最小值之间的像素点构成暗的区域。\nauto_threshold #  多阈值分割。根据多个波峰分割出多个独立的区域。\ndyn_threshold #  基于参考图像(由原图进行滤波得到)的动态阈值分割。\nvar_threshold #  基于结构元素，使用局部均值和标准偏差分析分割图像。\n dyn_threshold 和 var_threshold的适用场合：\n1）对于一些应用来说，无法通过一个全局阈值进行分割：图像的背景是非均匀的；\n2）物体在局部范围内通常比背景亮些或暗些。\n "});index.add({'id':12,'href':'/docs/blob/','title':"Blob",'section':"Docs",'content':"Blob #  流程 #   采集图像(1. 本地图像；2.相机接口)(read_image) 图像分割(threshold) 形态学处理(closing_circle, medium_image, erosion, dilation) 连通性分析(region, connection) 填充(fill_up, fill_up_shape) 特征提取(直方图, 检测)(select_shape) 获取结果  描述 #    read_image\n读取图片\n  threshold\n给目标物(如回形针)着色，从背景图中区分出\n  closing_circle\n给threhold着色时，没有着色的部分补充着色。(根据调整参数，尽可能让需要着色的空洞能着色，不需要着色的部分不会被着色)\n  connection:\n  ​\t将多个目标物(如回形针)组成的一个整体切割成多个(数组)，得到回形针数组\n  fill_up_shape\n根据自定义的特征进行填充\n  select_shape\n缩小目标范围，去除不相干内容\n  area_center\n获取区域的中心点坐标和面积\n  dev_desplay\n展示指定的图像\n  备注 #   图像类型数组，下标从1开始，且只能通过算子(如select_obj)读取  "});index.add({'id':13,'href':'/docs/%E5%BC%82%E5%B8%B8/','title':"异常",'section':"Docs",'content':"异常 #  代码格式：\ndev_set_check('give_error')\rtry\r//do something\rcatch(Exception)\r//Exception第0个元素：错误代码，第2个元素：错误描述，第5个元素：产生错误的算子\rendtry\r"});index.add({'id':14,'href':'/docs/%E5%87%A0%E4%BD%95%E5%AE%9A%E4%BD%8D/','title':"几何定位",'section':"Docs",'content':"几何定位 #  通过几何特征(如模板轮廓)，来判断图像中是否有目标区域。\n金字塔等级 #  等级越高，占用内存越少、匹配度要求越低；但等级过高时，会导致匹配出错\n极性 #    use_polarity 使用极性，在白色背景中找黑色目标\n  ignore_global_polarity 忽略全局极性，可以在白色背景中找黑色目标，也可以在黑色背景中找白色目标\n  ignore_local_polarity 忽略局部极性，可以适应更差的环境，可以在背景不稳定，如渐变的情况下找目标\n  匹配助手 #   贪心算法，值越大，处理时间越短，但可能会漏匹配部分区域，一般设置在0.7~0.8； 最大重叠，值越大，允许重叠的比例越大，但可能会匹配错； 最大变形，值越大，处理时间越长，但可以尝试匹配的区域越多；  对比度 #  对比度 = 相邻像素点、像素值的差值/距离\n建模经验 #   什么是关键轮廓，什么是干扰轮廓； 边缘数量越少越好；边缘数量多了，速度变慢； 边缘越长越好； 干扰边缘越少越好； 关键边缘越长越好，占模板轮廓的比例越多越好； 可以使用PS软件，制造理想的模板图像 灵活运用区域操作技术，获取关键边缘区域；  difference: 特别是回型区域、挖洞大法； union    定位经验 #   频繁调节的参数：角度、缩放、分数、极性； 多次搜索策略(分类)：匹配分数逐步降低；for循环 合理设置旋转角度范围； 合理设置贪婪度：定位要求高，贪婪度越小越好，但时间会边长； 有效提高匹配分数的措施：缩放，会增加时间。（对分数提高效果：异步缩放 \u0026gt; 同步缩放 \u0026gt; 不缩放，要合理设置缩放)。  定位的主要作用 #   最常用：粗定位 -\u0026gt; 仿射变换矩阵(模板轮廓变换矩阵、ROI变换矩阵) -\u0026gt; 模板轮廓跟随、ROI跟随； 异形定位：对定位参数要求高；对于定位准确性、**精确性(edges_sub_pix)**理解要求高； 定位结果是相对值，相对于模板的：  xy： 对于同一个模板图像，每次重新建模，模板中心xy都会变，如果直接使用模板中心，每次都需要调节xy补偿量；如果使用blob或测量进行精定位，则不需要调节； 角度：如果是异形件， 没有办法抓直边或2个以上的mark点，直接使用模板角度(角度精度不是非常高)；如果有办法抓直边或2个以上的mark点，这种方法精度高。    "});index.add({'id':15,'href':'/docs/%E7%9B%B8%E6%9C%BA%E5%9B%BE%E5%83%8F%E9%87%87%E9%9B%86/','title':"相机图像采集",'section':"Docs",'content':"相机图像采集 #  最频繁调节的参数 #    曝光，exposure\n  增益，gain\n  触发， trigger\n 注，exposure数值越大，拍照所需时间越长；gain数值越大，图像越亮，噪点越多越明显；trigger分为 硬触发、软触发;\n   相机采集代码流程示例 #    关闭相机所有图像采集设备\nclose_all_framegrabbers()\n  打开并配置图像采集设备\nopen_framegrabber(\u0026lsquo;GigEVision\u0026rsquo;, 0, 0, 0, 0, 0, 0, \u0026lsquo;default\u0026rsquo;, -1, \u0026lsquo;default\u0026rsquo;, -1, \u0026lsquo;false\u0026rsquo;, \u0026lsquo;default\u0026rsquo;, \u0026lsquo;ccd1\u0026rsquo;, 0, -1, AcqHandle)\n  设置触发\nset_framegrabber_param(AcqHandle, \u0026lsquo;TriggerMode\u0026rsquo;, \u0026lsquo;Off\u0026rsquo;)\n  设置快门\nset_framegrabber_param(AcqHandle, \u0026lsquo;ExposureTime\u0026rsquo;, 4693.0)\n  设置增益\nset_framegrabber_param(AcqHandle, \u0026lsquo;Gain\u0026rsquo;, 3.0156)\n  采集图像\ngrab_image(Image, AcqHandle)\n  关闭图像采集设备\nclose_framegrabber(AcqHandle)\n  "});index.add({'id':16,'href':'/docs/%E5%9B%BE%E5%83%8F%E9%A2%84%E5%A4%84%E7%90%86/','title':"图像预处理",'section':"Docs",'content':"图像预处理 #     对噪声的处理效果 对边缘的处理效果 效率     平滑滤波 弱化噪声 模糊边缘   中值滤波 去除噪声 保持边缘    滤波 #  针对有噪点的图像进行平滑，可以减弱或消除噪点\n mean_image median_image  锐化 #  对图像边缘进行对比度提升使用，可以让图像轮廓更清晰\n sobel_amp frei_amp  增强 #  emphasize\n形态学 #   腐蚀, erosion 膨胀, dilation  骨架 #  skeleton\n"});index.add({'id':17,'href':'/docs/%E7%A1%AC%E4%BB%B6/','title':"硬件",'section':"Docs",'content':"相机硬件 #    相机靶面尺寸 = 分辨率 * 像元尺寸\n  像元越大，成像效果越好\n  相机分辨率 * 最大帧率 \u0026lt;= 千兆网带宽\n  图像大小 * 相机稳定工作帧率 * 相机数量 \u0026lt;= 千兆网带宽\n  千兆网带宽：1000 / 8 = 125M\n  帧率 = 1 / 曝光\n  相机首选 ，CA, 600万像素；CE, 2000万像素(2000多人民币)；\n  "});index.add({'id':18,'href':'/docs/%E6%A8%A1%E6%9D%BF/','title':"模板",'section':"Docs",'content':"创建\u0026amp;保存\u0026amp;读取\u0026amp;使用模板 #  经验 #   金字塔等级(NumLevels)越高，匹配时间越短，但匹配越模糊，容易多匹配； 贪婪度(Greedness)越高，匹配时间越长，匹配越精确； 匹配分数(Score)越高，匹配越精确； 单模板支持x,y同步缩放、异步缩放；多模板不支持缩放。  创建模板 #  dev_get_window (WindowHandle1)\rdev_set_draw ('margin') //区域展示样式：边框\rread_image (Image, 'printer_chip/printer_chip_01')//加载图像\rdraw_rectangle2 (WindowHandle1, Row2, Column, Phi, Length1, Length2)//绘制模板区域\rgen_rectangle2 (Rectangle, Row2, Column, Phi, Length1, Length2)//展示区域\rreduce_domain (Image, Rectangle, ImageReduced)//获取图像在区域内的部分内容图像\rcreate_shape_model (ImageReduced, 'auto', 0, rad(45), 'auto', 'auto', 'use_polarity', 'auto', 'auto', ModelID)//将区域内的部分图像作为模板内容，制作模板\r保存模板 #  write_shape_model (ModelID, 'C:/Users/lee/Desktop/model.shm')\r读取模板 #  read_shape_model ('C:/Users/lee/Desktop/model.shm', ModelID)\r使用(查找)模板 #  find_shape_model (Image, ModelID, rad(-45), rad(180), 0.5, 1, 0.5, 'least_squares', 0, 0.9, Row3, Column2, Angle, Score)//判定有无，此处是几何定位法\rif (|Row3| \u0026gt; 0)\rvector_angle_to_rigid (0,0,0, Row3, Column2, Angle, HomMat2D)//获得变换矩阵HomMat2D\rget_shape_model_contours (ModelContours1, ModelID, 1)//会将模板轮廓显示在图像左上角，模板中心在图像坐标0，0的位置\raffine_trans_contour_xld (ModelContours1, ContoursAffineTrans1, HomMat2D)//根据变换矩阵，将模板轮廓仿射变换到对应的位置\relse disp_message (WindowHandle1, '未找到模板', 'window', 20, 20, 'red', 'false')\rendif\r参考图 #  "});index.add({'id':19,'href':'/docs/%E5%B8%B8%E7%94%A8%E6%A0%87%E5%AE%9A/','title':"常用标定",'section':"Docs",'content':"常用标定 #   像素变换(圆、矩形、像素单量)； 透视投影及光学畸变校正； 不同坐标系之间的标定(三点确定一个坐标系)：如九点标定(机械手) 多个相机通过标定统一到同一个坐标系  "});index.add({'id':20,'href':'/docs/%E4%BB%BF%E5%B0%84%E5%8F%98%E6%8D%A2/','title':"仿射变换",'section':"Docs",'content':"仿射变换 #  仿射变换可以理解为“跟随”， 即目标物体移动到哪里，相应轮廓、ROI等跟随到哪里。\n在基于参考的视觉检测中，由于待检测图像与参考图像或多或少都会存在几何变化(平移、旋转、缩放等)，所以一般都要对待检测图像或ROI进行仿射变换操作。\n仿射变换有平移、旋转、缩放、斜切(切变)。\n 注，两个坐标系Y轴的旋转角度，叫斜切角。\n机器X与Y 轴之间的角度不是绝对的90度，从原点沿着Y轴方向不断移动时，X方向的偏移会越来越大，在求图像坐标系和机器坐标系映射关系时，不能忽略了斜切角的影响。\n九点标定可以比较准确的求出斜切角。\n 流程 #   mermaid.initialize({ \"flowchart\": { \"useMaxWidth\":true }, \"theme\": \"default\" } ) graph TD\rA[\"获取特征点坐标，角度 \"] -- B[\"计算仿射变换矩阵\" ]\rB -- C[\"对图像，区域，轮廓进行仿射变换\"]\r三种常见类型 #    根据特征点、角度计算仿射变换矩阵。\n如， vector_angle_to_rigid，支持平移、旋转，参数：\n   \u0026mdash; 角度 位置(x,y)     对模板轮廓进行变换 0 (0, 0)   对ROI进行变换(包括模板区域) 0 模板区域中心(用area_center获得)    hom_mat2d_scale，支持缩放。\n  根据两个以上特征点计算仿射变换矩阵。\n如，\tvector_to_rigid，支持平移、旋转；\tvector_to_similarity，支持平移、旋转、缩放。\n  根据三个以上特征点获取仿射变换矩阵。\n如，vector_to_hom_mat2d，支持平移、旋转、缩放、斜切。\n适用于“手眼标定”（九点标定）、多相机标定到同一坐标系。\n   ※重要：此算子处理的是，画原模板时的区域（如 circle, rectangle）位置(如area_center得到的中心点位置) 到 find_shape_model 得到的新模板位置的变换矩阵\n 常用的仿射变换 #   affine_trans_contour_xld: 对XLD轮廓进行仿射变换； affine_trans_image: 对图像进行仿射变换； affine_trans_point_2d: 对二维点进行仿射变换； affine_trans_pixel: 对图像点进行仿射变换； affine_trans_region: 对区域进行仿射变换。  下载参考示例\n"});index.add({'id':21,'href':'/docs/%E6%B5%8B%E9%87%8F/','title':"测量",'section':"Docs",'content':"测量 #  工业测量的基础——卡尺工具。\n卡尺工具过程 #   确定边缘检测方向； 高斯滤波； 执行投影处理； 执行微分（对比度）处理； 设置边缘敏感度（对比度阈值）、边缘极性、边缘的位置； 边缘执行亚像素处理。  一维测量流程 #   mermaid.initialize({ \"flowchart\": { \"useMaxWidth\":true }, \"theme\": \"default\" } ) graph TD\rA[\"采集图像\"] -- B[\"创建测量对象\" ]\rB -- C[\"测量\"]\rC -- D[\"销毁测量对象\"]\r 需要熟练使用的一维测量工具：测量助手\n 二维测量流程 #  graph TD\rA[\"采集图像\"] -- B[\"按顺序创建边缘测量ROI(卡尺工具)\" ]\rB -- C[\"边缘测量\"]\rC -- D[\"把边缘连接成XLD多边形轮廓\"]\rD -- E[\"拟合\"]\r 拟合方法：\n 回归线法（无损拟合） 加权法（奇异点进行加权处理，距离XLD越远，权重越小）：huber 抛点法（抛除奇异点）：tukey   "});index.add({'id':22,'href':'/posts/halcon%E6%8F%8F%E8%BF%B0%E6%9C%89%E9%94%99%E8%AF%AF%E7%9A%84%E7%AE%97%E5%AD%90/','title':"Halcon描述有错误的算子",'section':"常见问题",'content':"1. hom_mat2d_translate #  定义： hom_mat2d_translate( : : HomMat2D, Tx, Ty : HomMat2DTranslate)\n错误：Tx, Ty反了，应该是hom_mat2d_translate( : : HomMat2D, Ty, Tx : HomMat2DTranslate)\n2. affine_trans_point_2d #  定义：affine_trans_point_2d( : : HomMat2D, Px, Py : Qx, Qy)\n错误：Px, Py反了，Qx, Qy反了，应该是affine_trans_point_2d( : : HomMat2D, Py, Px : Qy, Qx)\t\n综上，Halcon算子中，总是先用y坐标(Row)， 再用x坐标(Column)\n"});index.add({'id':23,'href':'/posts/halcon%E7%AE%97%E5%AD%90%E6%96%87%E6%A1%A3/','title':"Halcon算子文档",'section':"常见问题",'content':"每个算子的定义，都是由三个 冒号 : 分割的4组参数，分别表示 图形输入参数 : 图形输出参数：控制变量输入参数：控制变量输出参数\n"});index.add({'id':24,'href':'/posts/%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3/','title':"System.InvalidOperationException:线程间操作无效: 从不是创建控件 ** 的线程访问它。",'section':"常见问题",'content':"在使用Thread 多线程时，线程间不能跨线程访问其他线程的控件。\n如，主线程创建了某个label控件，子线程不能直接访问该控件，若想访问，则可以在Form窗体初始化函数中设置CheckForIllegalCrossThreadCalls = false， 否则会报以下类似的错误：\u0026quot;System.InvalidOperationException:线程间操作无效: 从不是创建控件 ** 的线程访问它。\u0026quot;\nMSDN参考连接\n"});index.add({'id':25,'href':'/docs/examples/custom/%E7%94%BB%E7%9B%B4%E7%BA%BF/','title':"画直线",'section':"自定义函数",'content':"函数名 #  custom_gen_line(:Line:Row, Col, Angle, Length, RegionOrXld:)\n 注释，\n输出参数，Line\n输入参数，\nRow: 起始点Y坐标；Col: 七十点X坐标；Angle: 角度；Length: 直线的长度；RegionOrXld: 结果类型，可选值有region, xld\n 函数体 #  dev_update_off () if(Length \u0026lt; 1) return () endif if(RegionOrXld == 'region') gen_region_line (LineTemp, 0, 0, 0, Length-1) else gen_contour_polygon_xld (LineTemp, [0,0], [0, Length-1]) endif * 求仿射变换矩阵 vector_angle_to_rigid (0,0,0, Row, Col, Angle, HomMat2D) if(RegionOrXld == 'region') affine_trans_region (LineTemp, Line, HomMat2D, 'false') else affine_trans_contour_xld (LineTemp, Line, HomMat2D) endif dev_update_on () return () 调用 #  read_image (Image, 'fabrik') custom_gen_line (Line, 100, 100, rad(-45), 100, 'region') custom_gen_line (Line1, 200, 200, rad(-45), 100, 'xld') 示例下载\n"});index.add({'id':26,'href':'/docs/examples/%E8%A3%81%E5%89%AA%E5%9B%BE%E5%83%8F/','title':"裁剪图像",'section':"示例",'content':"read_image (Image1, 'fabrik') gen_rectangle1 (Region, 181,288,305,350)//产生区域 reduce_domain (Image1, Region, ImageReduced)//减少定义域 crop_domain (ImageReduced, ImagePart)//裁剪图像 "});index.add({'id':27,'href':'/docs/examples/%E5%9B%BE%E5%83%8F%E4%BA%8C%E5%80%BC%E5%8C%96/','title':"图像二值化",'section':"示例",'content':"*生成二值化图像 *方法一，region_to_bin read_image (Image, 'fabrik') threshold (Image, Region, 170, 255) get_image_size (Image, Width, Height) region_to_bin (Region, BinImage, 255, 0, Width, Height) //根据区域产生二值化图像 stop() * 方法二，paint_region read_image (Image, 'fabrik') gen_rectangle1 (Rectangle, 181,288,305,350)//产生区域 paint_region (Rectangle, Image, ImageResult, 255, 'fill')//把区域绘制为灰度值255 complement (Rectangle, RegionComplement)//获取区域的补集 paint_region (RegionComplement, ImageResult, BinImage, 0, 'fill') stop() "});index.add({'id':28,'href':'/posts/%E5%9B%BE%E5%BD%A2%E7%B1%BB%E5%9E%8B%E6%95%B0%E7%BB%84vs%E6%8E%A7%E5%88%B6%E7%B1%BB%E5%9E%8B%E6%95%B0%E7%BB%84/','title':"图形类型数组VS控制类型数组",'section':"常见问题",'content':"  图像类型数组，下标从1开始，且只能通过算子(select_obj)一个个读取；\n  控制类型数组，下标从0开始，可以通过数字下标 Arr[index] 形式来读取。\n  "});index.add({'id':29,'href':'/posts/%E5%87%A0%E4%BD%95%E5%AE%9A%E4%BD%8Dblob%E5%88%86%E6%9E%90/','title':"几何定位\u0026Blob分析",'section':"常见问题",'content':"都是“判定有无” （判断图像中是否存在目标区域）的方法。\n  几何定位是通过(模板)轮廓等几何特征匹配，来判断图像中是否存在目标区域；\n  Blob分析是通过灰度值、特征值(如面积)等方式筛选，来判断图像中是否存在目标区域。\n  灰度定位(Blob)与几何(轮廓)定位对比:\n      对非线性光照变化，对物体灰度非线性变化的适应性 对缩放的适应性 对旋转的适应性 对物体遮挡、缺失的适应性 时间     灰度定位 差 差 差 差 短   几何(轮廓)定位 好 好 好 好 长    "});index.add({'id':30,'href':'/docs/image/operators/list_files/','title':"list_files",'section':"相关算子",'content':"列举文件 #  "});index.add({'id':31,'href':'/docs/image/operators/orientation/','title':"orientation",'section':"相关算子",'content':"orientation #  "});index.add({'id':32,'href':'/docs/image/operators/select_shape/','title':"select_shape",'section':"相关算子",'content':"select_shape #  "});index.add({'id':33,'href':'/posts/hotkeys/','title':"Windows下的快捷键",'section':"常见问题",'content':"快捷键 #   F2: 重置程序执行，停止执行程序，清零所有变量； F3: 取消注释所在行； F4: 注释所在行； F5: 运行程序(遇到断点会暂停)； F6: 单步步过执行(不进入自定义函数内部)； F7: 单步步入执行，会进入自定义函数内部(内置函数除外)； F8: 步过执行完成当前函数，到前一个函数后面； F9: 停止执行； F10: 给当前行加断点。 使用灰度直方图时，按ctrl键，鼠标放在图像上可以到看灰度值。  "});index.add({'id':34,'href':'/posts/relative_path/','title':"使用相对路径加载图像",'section':"常见问题",'content':"好处 #  共享程序文件给他人时，不用严格按照原有的绝对路径存储图像，方便使用。\n位置 #  read_image可以将hdev文件所在目录，作为相对路径起始位置。\n"});index.add({'id':35,'href':'/docs/3d%E6%B5%8B%E9%87%8F/%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF/','title':"关键技术",'section':"Docs",'content':"关键技术 #  3D测量适合测高度，X、Y方向的精度不高\n线激光和相机的角度 #  一般在10~60度，角度越大，精度越高。。。\n场合 #  拍摄反光较强的表面时，相机、激光都要与拍摄物有一定角度。\nZ方向分辨率 #  Z方向的分辨率 = X方向分辨率 * 常量(夹角决定)\n简易算法： Z方向像素j单量 = Height / Width (Height:用于测量的矩形块高度， Width:视场长度)\nZ方向重复性 #  一体式相机： Z方向重复性 = X方向像素单量 * 系数 （系数在0.5 ~ 2 之间，初次选型，可采用参考值1.5）\n分体式相机：Z方向重复性 = X方向像素单量 / tanα * 系数(1-3) ， 角度参考值为45°(此时tanα = 1)\nZ方向像素单量 = X方向像素单量 / tanα\nY方向 #  线激光传感器在机器人手臂上时，是时间频率拍照，没法触发拍照。\n扫描间隔/触发间隔 #  扫描间隔(距离, 单位mm) = 扫描(脉冲)间隔 * 脉冲单量\n曝光方式 #  建议使用多曝光方式，特别是有色差的物体。\n光亮控制 #  可以通过调整激光电压来改变激光的亮度。\n轮廓线提取 #   激光线与2D图像X轴平行； 按列搜索； 有效点阈值； 有效点选择 倾斜补正  halcon图像数据类型 #   halcon算子支持的图像数据类型一般有限制，需要查看帮助文档，获取支持的类型 常用图像数据类型：byte, uint2 图像数据类型转化算子:convert_image_type halcon轮廓匹配支持的类型：byte, uint2  参考面补正 #   3D测量尽量做相对测量（相对于参考面），数据重复性好；避免做绝对测量； 用轮廓线测量背景，若是平的(变化不大)，用大平面补正；若是凹凸不平的，用曲面补正(分割成多个小平面，再拉直补正)  3D测量常用方法 #    高度差/段差\n在高度差测量位置，生成两个临近 的区域，求两个区域的平均高度值(min_max_gray)，两个高度值之差为该位置的高度差。\n  平面度\n 生成一些小的测量点 多个三维点点拟合平面 。。。    体积\n物体的体积 = X方向分辨率 * Y方向分辨率 * 物体面积(像素单位) * 高度平均值(单位mm)\n  轮廓和截面的2.5D测量 #  基于轮廓线的测量\n激光器 #  最佳工作距离：65mm\n要调节激光水平，使其与X轴平行\n相机和镜头调节 #   调节合适的曝光、增益、镜头光圈，让每列激光饱和（亮度值200以上）的像素个数达2个以上。曝光不能过大，否则会降低相机帧率。  备注 #   点云图、高度图中的像素值是高度信息； 亮度图的像素值是亮度信息； 分频倍率 = X方向分辨率 / Y方向分辨率，然后取整；   "});index.add({'id':36,'href':'/docs/3d%E6%B5%8B%E9%87%8F/%E5%9F%BA%E7%A1%80%E6%B5%8B%E9%87%8F/','title':"基础测量",'section':"Docs",'content':"基础测量 #  准备工作 #    调整相机的帧率、曝光时间、增益、ROI等参数，使实际帧率达到200以上；\n  调整相机轴臂移动速度、触发模式(开)，使的X轴每移动指定距离(如5mm)时，相机的拍照图像张数基本固定(多次测量前后数量相差3张以内)。\n  X方向分辨率(像素单量) #  指的是X轴方向，每个像素代表的实际距离(一般单位是mm，或um)\n测量方法 #   用相机拍摄一段尺子(如10mm)； 在Halcon中使用测量助手 打开照片； 通过画直线，调整最小边缘幅度、平滑等参数，得出图像中某一长度(如10mm)对应的像素个数； X方向分辨率 = 物理距离 / 像素个数，单位 mm/pixel  Y方向分辨率(像素单量) #  指的是Y轴方向，每个像素代表的实际距离(一般单位是mm，或um)\n测量方法 #   相机开启触发模式； 让相机轴臂低速(保证帧率)移动指定距离(如5mm)，记录照片张数； Y方向分辨率 = 移动距离 / 照片张数，单位 mm/pixel  "});index.add({'id':37,'href':'/docs/image/operators/%E7%81%B0%E5%BA%A6%E7%9B%B4%E6%96%B9%E5%9B%BE/','title':"灰度直方图",'section':"相关算子",'content':"借助灰度直方图创建threshold代码 #  发音：ˈθreʃhəʊld\n阈值 (不是_阀值_)又叫临界值，是指一个效应能够产生的最低值或最高值。此一名词广泛用于各方面，包括建筑学、生物学、飞行、化学、电信、电学、心理学等，如生态阈值。（摘自百度百科）\n前提 #  需要将通过read_image读取图像得到的Image类型变量作为参数。\n使用方式 #   通过read_image 读取图像； 打开灰度直方图，并勾选 阈值选项； 调整绿线和红线，勾勒出目标物； 点击插入代码。  提醒 #  若无法勾选阈值选项，看下阈值行的通道 是不是RGB，若是，选择某一具体值，这时阈值选项即可勾选了。\n参考图 #  使用代码获取灰度直方图 #  * 读取图像\rread_image(Image, 'clip')\r* 产生直方图\rgray_histo (Image, Image, AbsoluteHisto, RelativeHisto)\r* 产生直方图区域\rgen_region_histo (Region, AbsoluteHisto, 255, 255, 1)\r* 根据直方图求分割阈值\rhisto_to_thresh (AbsoluteHisto, 2, MinThresh, MaxThresh)\r* 阈值分割\rthreshold (Image, Region1, MinThresh, MaxThresh)\r"});index.add({'id':38,'href':'/docs/%E5%BD%A2%E6%80%81%E5%AD%A6/','title':"形态学",'section':"Docs",'content':"形态学 #   腐蚀 (erosion1, erosion_rectangle1, erosion_circle) 膨胀(dilation1, dilation_rectangle1, dilation_circle) 开运算(opening_*) 闭运算(closing_*)  描述 #   腐蚀：去除毛刺 开运算：先腐蚀再膨胀，作用是去除毛刺的同时，减少面积的丢失。  "});index.add({'id':39,'href':'/docs/%E7%A1%AC%E4%BB%B6/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/','title':"基础知识",'section':"Docs",'content':"基础知识 #  拖影 #  拖影由运动速度和曝光时间影响导致，速度越快，或曝光时间越长，拖影越明显。\n如何拍照，使照片教亮？ #   光源亮度调大 适当调大增益（但增益越大，噪点越多） 光圈调大（进入的光线会变多） 延长曝光时间（但会出现拖影）  相机电压 #  通用12V\n相机保护 #  相机信号输出时，加光耦保护\n使用触发的好处 #  占用带宽少。（触发方式常用 edge方式）\n"});index.add({'id':40,'href':'/readme/','title':"R E a D M E",'section':"图像处理",'content':"halcon_content #  文章内容, markdown格式\n"});})();